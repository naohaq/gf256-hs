
module Main where

import Data.GF2Extension
import Data.GF256
import Data.Bits
import qualified Data.Word as W
import qualified Polynomial as P

type F256 = GF256 PP301

gen_ecc200 :: Int -> [F256]
gen_ecc200 x = foldr P.mul [1] $ map e [1..x]
  where e :: Int -> [F256]
        e k = [1, pow2 k]

gp_pp301_18 :: [F256]
gp_pp301_18 = gen_ecc200 18

cws :: [W.Word8]
cws = [0x8e, 0x32, 0x2e, 0xbe, 0x92, 0x35, 0x2e, 0x83,
       0x21, 0x73, 0x66, 0x77, 0x21, 0x86, 0x21, 0x92,
       0x8a, 0x4c, 0x4a, 0x82, 0x86, 0x37, 0x24, 0xa3,
       0xa7, 0x8e, 0xf0, 0x7b, 0xea, 0x38, 0xe7, 0x57,
       0xcd, 0x1d, 0x7a, 0x7e, 0xd8, 0xb2, 0x24, 0xe9]

ews :: [W.Word8]
ews = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

check_ecc200 :: (Integral a) => [a] -> [F256]
check_ecc200 ds = dp `P.mod` gp_pp301_18
  where dp = map (fromInt.fromIntegral) ds

main :: IO ()
main = do
  putStrLn $ show $ check_ecc200 cws
  putStrLn $ show $ check_ecc200 ews
  putStrLn $ show $ check_ecc200 $ zipWith xor cws ews

-- EOF
